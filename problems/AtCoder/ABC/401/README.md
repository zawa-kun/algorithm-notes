# [ABC401](https://atcoder.jp/contests/abc401/tasks)
---
## C問題
### 模範解答
```Python
n, k = map(int, input().split())
s = k
a = [1 for i in range(n + 1)]
for i in range(k, n + 1):
    a[i] = s
    s -= a[i-k]
    s += a[i]
    s %= 1000000000
print(a[n])

```
### 振り返り
**疑問**>>>なぜMODをAに格納していくのか。最後にMODを取る形ではダメなのか。
**解答**
1. Python以外の言語では桁あふれをするから
2. スピードと安定性のバランス

途中で値が大きくなりすぎると、メモリや実行時間に影響が出てくる（👈ＴＬＥになった原因）⇒毎回ＭＯＤを取っておくことで0～MOD-1に収まる為、安定する。

ちなみにＭＯＤを取っても答えが変わらないのは**合同式の性質によるもの**


Pythonの整数（INT型）は30bit以上から、配列で扱うようになる（以下参照）から、
```
ob_digit[0] = 最下位30bit、ob_digit[1] = 次の30bit、…
```
大きな数値になればなるほど、メモリ確保も再計算も増えて、計算が重くなってくる。

---
今回みたいなミスを起こさない為に言語の特徴を知ることも重要であると実感した。