# C
流れ
1. 砲台の防御範囲を記録
2. 何個壊せばいいか確認
普通にやったらO(N**2)かか


壁をlistにし、何個の砲台に守られているを記録
[0, 0, 0, 0, 0]のような状態で初期化する.
最小値を探し、それを出力。
かかる時間は1の記録する過程のみ(最大M*N)
```python
for _ in range(M):
    L, R = map(int, input().split())
    for i in range(L-1, R):
        wall[i] += 1

print(min(wall))
```

👆これだとTLEだった

砲台の防御範囲を記録するのをもっと効率的にしたい。



出力から逆算してみる
最終的に最も最小の壁が出力される。

以下の二つがTLEの原因
1. 最小を求めるのが時間かかっているのかな？
2. 壁塗りの時間


始まりが１組、２組、３組のように分けて言ってみるのはありかも。
まあ分けてどうするのかって話だけど。
わけてスライディングウィンドウのような形で記録していく。まず記録するのが邪道か？
数を見るっていうよりは大小関係のみでどれだけの砲台が守られているかを確認する。

👆これも計算量変わらんな。