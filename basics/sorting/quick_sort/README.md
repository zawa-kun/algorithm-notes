# クイックソート(Quick Sort)　O(n log n)
## 概要
「分割統治法」の考え方に基づいたソートアルゴリズム。配列内の要素(pivot)を選び、それより小さい要素と大きい要素に分割し、再帰的に同じ処理を繰り返す事で整列を行う.
## 手順
1. 配列の最後の要素をpivotとする.
2. pivotより小さい値をピボットの左側に、大きい要素を右側に移動させる。
- 小さい要素のインデックスを追跡する変数iを-1で初期化.
- 配列の先頭から順に各要素jを調べていく.
- もしpivot >= list[j]なら,iを増やして,swap(list[i], list[j])
3. 全ての要素をチェックしたら, pivotを適切な位置(i+1)に配置.
4. pivotの右側、左側に対し、1~3の処理を再帰的に適用.
5. 部分配列のサイズが１以下になったら,その部分は整列完了とみなす.
## 計算量
| 最良計算量 | 平均計算量 | 最悪計算量 | 
|------------|------------|------------|
| O(n log n) | O(n log n) | O(n^2) | 
## 使い道
- 大規模なデータセットの効率的な整列
- 平均的に優れたパフォーマンスが必要な場合
- **メモリ使用量が制限されている環境**
- 多くのプログラミング言語の標準ライブラリでソートアルゴリズムとして採用.(C++, Java, 以前のPython, JavaScript, Swift, Go)

※quick sortがそのまま使われているのではなく、クイックソートベースのソートが使われているという事.
