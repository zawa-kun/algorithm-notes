# ビット全探索（Bit Full Search）

各要素が「選ばれる」か「選ばれない」の２通りの状態を持つことを利用し、これをビット列で表現。

- k番目のビットが立っている（1である）: k番目の要素が選ばれる
- k番目のビットが立っていない（0である）：k番目の要素が選ばれる

0～ 2<sup>N</sup>-1 までの整数をループすることで、すべての部分集合をもれなくかつ重複なく調べることができる。

👉**N個の要素からなる集合の部分集合のをすべて列挙する際に有効。**
## 具体的なコード
```Python
N = 3
items = ['A', 'B', 'C']

# 2^N通りの部分集合をループ
for i in range(1 << N): # 2^Nと同義.
    selected_subset = []
    for j in range(N):
        if (i >> j) & 1: # i のj番目が1であればTrue
            selected_subset.append(items[j])
    print(f"整数{i} 二進数: {bin(i)}: 選択された部分集合: {selected_subset}")
```
```shell
整数0 二進数: 0b0: 選択された部分集合: []
整数1 二進数: 0b1: 選択された部分集合: ['A']
整数2 二進数: 0b10: 選択された部分集合: ['B']
整数3 二進数: 0b11: 選択された部分集合: ['A', 'B']
整数4 二進数: 0b100: 選択された部分集合: ['C']
整数5 二進数: 0b101: 選択された部分集合: ['A', 'C']
整数6 二進数: 0b110: 選択された部分集合: ['B', 'C']
整数7 二進数: 0b111: 選択された部分集合: ['A', 'B', 'C']
```

## どんな問題に使われるか
- 部分和問題：与えられた数値の集合から、合計がある値になる部分集合を見つける
- 最小費用問題：複数の選択肢があり、それぞれの選択肢が別の選択肢と関連している場合に、合計費用が最小になる組み合わせを見つける
- 集合被覆問題：複数の集合の中から、ある要素の集合をすべてをカバーするために必要な最小数の集合を見つける
- ナップサック問題：容量が限られたナップサックに、価値と重さを持つアイテムを詰め込み、価値の合計を最大化する。


## 注意点
- **計算量**：ビット全探索の計算量はO(N×2<sup>N</sup>)であり, Nが少し大きくなるだけで計算量が爆発的に増加するため、Nの制約が非常に重要になってくる。

## Pythonで効率的に書く方法
- Pythonではビット演算子``<<``（左シフト）, ``>>``（右シフト）, ``&``（ビットAND）, ``|``（ビットOR）, ``~``（ビット反転）を使いこなすことで、簡潔かつ効率的にコードを記述


